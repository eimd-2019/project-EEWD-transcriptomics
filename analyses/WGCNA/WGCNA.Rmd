---
title: "WGCNA"
author: "Yaamini Venkataraman"
date: "7/8/2020"
output: github_document
---

In this script, I will conduct a WGCNA to understand *Z. marina* gene expression patterns. The code is based on [ tutorials from the WGCNA package](https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/Tutorials/index.html).

# Set up R Markdown file

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "/Users/yaaminivenkataraman/Documents/project-EWD-transcriptomics/analyses/WGCNA/") #Set root directory
```

# Install packages

```{r}
#install.packages("dichromat")
#install.packages("BiocManager")
#BiocManager::install("WGCNA")
#install.packages("tidyverse")
#install.packages("patchwork")
#install.packages("grid")
```

```{r}
require(dichromat)
require(WGCNA)
require(tidyverse)
require(patchwork)
require(grid)
options(stringsAsFactors = FALSE) #Important setting to include from tutorial
```

# Obtain session information

```{r}
sessionInfo() #Obtain session information
```

# Format data

Relevant tutorial: https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/Tutorials/FemaleLiver-01-dataInput.pdf

## Import log CPM data

```{r}
zosteraAllGenes <- read.delim("../EdgeR/EXP.CON.Zostera.logCPM.txt", header = TRUE, quote = "") #Import data with log CPM information for all expressed genes
head(zosteraAllGenes) #Confirm import
```

```{r}
zosteraExpr0 <- as.data.frame(t(zosteraAllGenes[,-1])) #Transpose dataframe to format for WGCNA package. Do not include the first column of gene IDs
names(zosteraExpr0) <- zosteraAllGenes$GeneID #Use gene ID as column names
head(zosteraExpr0) #Confirm formatting
```

## Check for missing values and outliers

```{r}
gsg <- goodSamplesGenes(zosteraExpr0, verbose = 3) #Check for genes and samples with too many missing values
gsg$allOK #TRUE = all genes have passed test, can continue
```

```{r}
sampleTree <- hclust(dist(zosteraExpr0), method = "average") #Create dendogram to visually inspect for outliers
plot(sampleTree) #No obvious outliers, can proceed
```

## Create clinical trait data matrix

```{r}
zosteraTraits <- data.frame("exposed" = c(rep(1, times = 7), rep(0, times = 8))) #Create a dataframe with clinical trait (laby exposed vs. not exposed) information
rownames(zosteraTraits) <- rownames(zosteraExpr0) #Use same rownames as expression data to create an analagous matrix
head(zosteraTraits) #Confirm dataframe creation
```

```{r}
sampleTree2 <- hclust(dist(zosteraExpr0), method = "average") #Create a dendogram to look at sample and trait clustering
traitColors <- numbers2colors(zosteraTraits, signed = FALSE) #Convert traits to color values
plotDendroAndColors(sampleTree2, traitColors,
                    groupLabels = names(zosteraTraits)) #Plot dendogram. S_2A funky
```

```{r}
save(zosteraExpr0, zosteraTraits, file = "zostera-WGCNA-dataInput.RData") #Save expression and trait data
```

# Network connection and module detection

Relevant tutorial: https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/Tutorials/FemaleLiver-02-networkConstr-man.pdf

## Determine soft-thresholding power

```{r}
#lnames <- load(file = "zostera-WGCNA-dataInput.RData") #Load data input from previous section, if needed
```


```{r}
powers <- c(c(1:10), seq(from = 12, to = 20, by = 2)) #Create a set of soft-thresholding powers
sft <- pickSoftThreshold(zosteraExpr0, powerVector = powers, verbose = 5, networkType = "signed") #Use the network topology analysis function to evaluate soft-thresolding power values for signed network
```

```{r}
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab = "Soft Threshold (power)", ylab = "Scale Free Topology Model Fit,signed R^2", type = "n",
     main = paste("Scale independence")) #Plot scale-free topology fit index as a function of the soft-thresholding power
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2], labels = powers, cex = 1, col = "red") #Add sft values
abline(h=0.90,col="red") #Add line corresponding to a R^2 cutoff of h = 0.90. Lowest power that reaches 0.90 is sft = 16
```

```{r}
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab = "Soft Threshold (power)", ylab = "Mean Connectivity", type = "n",
     main = paste("Mean connectivity")) #Plot mean connectivity as a function of soft-thresholding power
text(sft$fitIndices[,1], sft$fitIndices[,5], labels = powers, cex = 1, col = "red") #Add sft values. 
```

## Co-expression similarity and adjacency

```{r}
softPower <- 16 #Set soft power based on plots above
adjacency <- adjacency(zosteraExpr0, power = softPower, type = "signed") #Calculate adjacencies using softPower = 16
```

## Topological Overlap Matrix (TOM)

```{r}
TOM <- TOMsimilarity(adjacency, TOMType = "signed") #Minimize noise and spurious associations by transforming adjacency into TOM
dissTOM <- 1-TOM #Calculate dissimilarity matrix
```

## Clustering using TOM

```{r}
geneTree <- hclust(as.dist(dissTOM), method = "average") #Create hierarchical clustering object
plot(geneTree, xlab = "", sub = "", main = "Gene clustering on TOM-based dissimilarity",
     labels = FALSE, hang = 0.04) #Plot initial dendogram. Dissimilarity is based on topological overlap
```

```{r}
minModuleSize <- 30 #Set the minimum module size (# of genes that need to be in a module). Default from WGCNA tutorial
dynamicMods <- cutreeDynamic(dendro = geneTree, distM = dissTOM,
                             deepSplit = 2, pamRespectsDendro = FALSE,
                             minClusterSize = minModuleSize) #Cut the branches of the dendogram to identify WGCNA modules
table(dynamicMods) #Look at the table of modules. There are 18 modules, and 9 genes that do not fit into a module (label 0). Modules have between 47 and 760 genes
```

```{r}
dynamicColors <- labels2colors(dynamicMods) #Convert module numbers into colors
table(dynamicColors) #Look at the list of colors
```

```{r}
plotDendroAndColors(geneTree, dynamicColors, "Dynamic Tree Cut",
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05,
                    main = "Gene dendrogram and module colors") #Plot dendogram with module colors 
```

## Merge modules with similar expression profiles

Merging allows us to combine modules with genes that are highly co-expressed. To do this, we can create eigengenes and cluster them.

```{r}
MEList = moduleEigengenes(zosteraExpr0, colors = dynamicColors) #Calculate eigengenes
MEs <- MEList$eigengenes #Save eigengenes as a new object
MEDiss <- 1-cor(MEs) #Calculate dissimilarity of eigengenes
METree <- hclust(as.dist(MEDiss), method = "average") #Create cluster object
```

```{r}
plot(METree, main = "Clustering of module eigengenes",
     xlab = "", sub = "") #Plot dendogram of clustered eigengenes
dynamicMergeCut(15) #Identify cut height based on sample number (15)
MEDissThres <- dynamicMergeCut(15) #Set cut height threshold based on the number of samples. 1-MEDissThres = correlation
abline(h = MEDissThres, col = "red") #Add cut line
```

```{r}
merge <- mergeCloseModules(zosteraExpr0, dynamicColors, cutHeight = MEDissThres, verbose = 3) #Use an automatic merging function to merge eigengenes
mergedColors <- merge$colors #Extract merged module colors
mergedMEs <- merge$newMEs #Extract eigengenes of merged modules
```

```{r}
plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors),
                    c("Dynamic Tree Cut", "Merged dynamic"), 
                    dendroLabels = FALSE, hang = 0.03, 
                    addGuide = TRUE, guideHang = 0.05) #Plot the dendogram with original and merged eigengene colors
```

## Rename and save variables for subsequent analysis

```{r}
moduleColors <- mergedColors #Rename to moduleColors
colorOrder = c("grey", standardColors(50)) #Determine color order
moduleLabels = match(moduleColors, colorOrder)-1 #Construct numerical lables based on colors
MEs <- mergedMEs #Replace unmerged MEs
```

```{r}
save(MEs, moduleLabels, moduleColors, geneTree, file = "zostera-WGCNA-networkConstruction.RData")
```

# Relate modules to external clinical traits (*Z. marina* exposed vs. control)

Relevant tutorial: https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/Tutorials/FemaleLiver-03-relateModsToExt.pdf

Code also modified from Wong et al. 2018: https://datadryad.org/stash/dataset/doi:10.5061/dryad.k214j

```{r}
#lnames <- load(file = "zostera-WGCNA-networkConstruction.RData") #Load data from the previous section, if needed
```

## Quantify module-trait associations

```{r}
nGenes <- ncol(zosteraExpr0) #Count the number of genes
nSamples <- nrow(zosteraExpr0) #Count the number of samples
```

```{r}
MEs0 <- moduleEigengenes(zosteraExpr0, moduleColors)$eigengenes #Recalculate MEs with colorlabels
MEs <- orderMEs(MEs0) #Order MEs based on MEs0
```

```{r}
moduleTraitCor <- cor(MEs, zosteraTraits, use = "p") #Calculate trait correlations
moduleTraitPvalue <- corPvalueStudent(moduleTraitCor, nSamples) #Obtain p-values
```

```{r}
# Will display correlations and their p-values
textMatrix <- paste(signif(moduleTraitCor, 2), "\n(",
                    signif(moduleTraitPvalue, 1), ")", sep = "") #Create text matrix for correlations and their p-values
dim(textMatrix) <- dim(moduleTraitCor) #Ensure that matrix has the same dimensions
```

```{r}
#pdf("module-treatment-relationships.pdf", width = 11, height = 8.5)

par(mar = c(4, 8.5, 3, 3)) #Change figure boundaries
labeledHeatmap(Matrix = moduleTraitCor,
               xLabels = "Exposed vs. Control",
               xLabelsAngle = 0,
               xLabelsAdj = 0.5,
               yLabels = names(MEs),
               ySymbols = names(MEs),
               colorLabels = FALSE,
               colors = blueWhiteRed(50), 
               textMatrix = textMatrix, 
               setStdMargins = FALSE, 
               cex.text = 0.5,
               zlim = c(-1,1),
               main = paste("Module-Treatment Relationships")) # Display the correlation values from textMatrix within a heatmap plot. Text is the correlation value along with p-value. Red colors represent positive correlations (1) and blue colors represent negative correlations (-1)

#dev.off()
```

```{r}
sigModules <- moduleTraitCor %>%
  as.data.frame(.) %>%
  dplyr::rename(., cor = exposed) %>%
  cbind(., as.data.frame(moduleTraitPvalue)) %>%
  dplyr::rename(., pvalue = exposed) %>%
  filter(., pvalue < 0.05) #Subset only significant modules
sigModules #4 significant modules, all have higher expression in exposed samples except for brown

# module cor pvalue
# MEbrown	-0.8637994	3.315596e-05		
# MEyellow	0.5151462	4.939245e-02		
# MEblue	0.9856425	1.992677e-11		
# MEmagenta	0.5227804	4.555661e-02	
```

## Gene significance and module membership

Module membership information is needed for downstream GO-MWU enrichment analysis. Gene significance may guide discussion writing.

```{r}
exposed <- as.data.frame(zosteraTraits$exposed) #Define "exposed" using the information from the trait matrix
names(exposed) <- "exposed" #Modify names
modNames <- substr(names(MEs), 3, nchar(names(MEs))) #Save module names without "ME" at the beginning of each entry.
```

### Gene significance

```{r}
geneTraitSignificance <- as.data.frame(cor(zosteraExpr0, exposed, use = "p")) #Obtain gene significance statistics
names(geneTraitSignificance) <- paste("GS.", names(exposed), sep = "") #Add column names
head(geneTraitSignificance) #Confirm formatting
```

```{r}
GSPvalue <- as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples)) #Obtain p-values for each gene significance statistic
names(GSPvalue) <- paste("p.GS.", names(exposed), sep = "") #Add column names
head(GSPvalue) #Confirm formatting
```

### Module membership

```{r}
geneModuleMembership <- as.data.frame(cor(zosteraExpr0, MEs, use = "p")) #Obtain gene module membership statistics
names(geneModuleMembership) <- paste("MM", modNames, sep = "") #Add column names
head(geneModuleMembership) #Confirm formatting
```

```{r}
MMPvalue <- as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), nSamples)) #Obtain p-values for each module membership statistic
names(MMPvalue) <- paste("p.MM", modNames, sep = "") #Add column names
head(MMPvalue) #Confirm formatting
```

# Obtain gene lists

```{r}
rownames(sigModules)
```

```{r}
modNames[c(1, 3, 4, 5)] #Only significant modules
```

```{r}
probes <- names(zosteraExpr0) #Save gene names as probes
# Write out the gene lists for each module of interest (significant modules)
for (module in modNames[c(1, 3, 4, 5)]) {
  modGenes <- (moduleColors == module) # Select module probes
  modLLIDs <- probes[modGenes] # Get their gene IDs
  fileName <- paste("zosteraGeneList-", module, ".txt", sep = "") #Assign filename for each module
  write.table(as.data.frame(modLLIDs), file = fileName, sep = "\t",
              row.names = FALSE, col.names = FALSE) # Write out files
}
```

## Count DEG in significant modules

```{r}
zosteraEdgeROutput <- read.delim("../EdgeR/EXP.CON.Zostera.ALL.txt") #Import Z. marina edgeR results (all genes, not just DEG)
head(zosteraEdgeROutput) #Confirm import
zosteraEdgeROutput <- data.frame("geneIDs" = rownames(zosteraEdgeROutput),
                                 "logFC" = zosteraEdgeROutput$logFC,
                                 "logCPM" = zosteraEdgeROutput$logCPM,
                                 "FDR" = zosteraEdgeROutput$FDR,
                                 "edgeR.pvalue" = zosteraEdgeROutput$PValue) #Only save gene ID, log fold change, log counts per million, FDR, and p-values from edgeR
head(zosteraEdgeROutput) #Confirm changes
```

### brown

```{r}
brownGeneList <- read.delim("zosteraGeneList-brown.txt", header = FALSE, sep = "\t", col.names = "geneIDs") #Import list of genes
nrow(brownGeneList) #457 genes in the brown module
left_join(x = brownGeneList, y = zosteraEdgeROutput, by = "geneIDs") %>%
  filter(., edgeR.pvalue < 0.05) %>%
  nrow(.) #266 DEGs in the brown module
```

### yellow

```{r}
yellowGeneList <- read.delim("zosteraGeneList-yellow.txt", header = FALSE, sep = "\t", col.names = "geneIDs") #Import list of genes
nrow(yellowGeneList) #230 genes in the yellow module
left_join(x = yellowGeneList, y = zosteraEdgeROutput, by = "geneIDs") %>%
  filter(., edgeR.pvalue < 0.05) %>%
  nrow(.) #36 DEGs in the yellow module
```

### blue

```{r}
blueGeneList <- read.delim("zosteraGeneList-blue.txt", header = FALSE, sep = "\t", col.names = "geneIDs") #Import list of genes
nrow(blueGeneList) #388 genes in the blue module
left_join(x = blueGeneList, y = zosteraEdgeROutput, by = "geneIDs") %>%
  filter(., edgeR.pvalue < 0.05) %>% 
  nrow(.) #319 DEGs in the blue module
```

### magenta

```{r}
magentaGeneList <- read.delim("zosteraGeneList-magenta.txt", header = FALSE, sep = "\t", col.names = "geneIDs") #Import list of genes
nrow(magentaGeneList) #126 genes in the magenta module
left_join(x = magentaGeneList, y = zosteraEdgeROutput, by = "geneIDs") %>%
  filter(., edgeR.pvalue < 0.05) %>% 
  nrow(.) #67 DEGs in the magenta module
```

## Master list with membership and gene significance information

```{r}
zosteraGeneAnnot <- read.delim("../../data/Zostera-blast-annot-withGeneID-noIsoforms.tab", header = FALSE, sep = "\t") #Import gene annotation information
zosteraGeneAnnot <- zosteraGeneAnnot[,-c(3,10)] #Remove unecessary columns
colnames(zosteraGeneAnnot) <- c("geneIDs", "Uniprot", "e-value", "annot", "BPGO", "CCGO", "MFGO", "GOterms", "organism")
head(zosteraGeneAnnot) #Confirm import and formatting
```

```{r}
zosteraGeneAnnot <- left_join(zosteraGeneAnnot, zosteraEdgeROutput, "geneIDs") #Add edgeR information to annotation table
head(zosteraGeneAnnot) #Confirm formatting
```

```{r}
probes2annot <- match(probes, zosteraGeneAnnot$geneIDs) #Match probes with annotations
sum(is.na(probes2annot)) #Check that no probe does not have an annotation. Should return 0
```

```{r}
geneInfo0 <- data.frame("geneID" = probes,
                        "Uniprot" = zosteraGeneAnnot$Uniprot[probes2annot],
                        "annot" = zosteraGeneAnnot$annot[probes2annot],
                        "BPGO" = zosteraGeneAnnot$BPGO[probes2annot],
                        "CCGO" = zosteraGeneAnnot$CCGO[probes2annot],
                        "MFGO" = zosteraGeneAnnot$MFGO[probes2annot],
                        "GOterms" = zosteraGeneAnnot$GOterms[probes2annot],
                        moduleColor = moduleColors,
                        geneTraitSignificance,
                        GSPvalue,
                        "logFC" = zosteraGeneAnnot$logFC[probes2annot],
                        "logCPM" = zosteraGeneAnnot$logCPM[probes2annot],
                        "FDR" = zosteraGeneAnnot$FDR[probes2annot],
                        "edgeR.pvalue" = zosteraGeneAnnot$edgeR.pvalue[probes2annot]) #Create starter matrix
head(geneInfo0) #Confirm matrix creation
```

```{r}
modOrder <- order(-abs(cor(MEs, exposed, use = "p"))) #Order modules by their significance for Laby exposure
for (mod in 1:ncol(geneModuleMembership)) {
  oldNames = names(geneInfo0)
  geneInfo0 = data.frame(geneInfo0, geneModuleMembership[, modOrder[mod]],
                         MMPvalue[, modOrder[mod]])
  names(geneInfo0) = c(oldNames, paste("MM.", modNames[modOrder[mod]], sep=""),
                       paste("p.MM.", modNames[modOrder[mod]], sep=""))
} #Add module membership information in the chosen order
geneOrder <- order(geneInfo0$moduleColor, -abs(geneInfo0$GS.exposed)) #Order genes by module color, then gene trait significance
geneInfo <- geneInfo0[geneOrder,] #Reorder genes into a final matrix
geneInfo <- geneInfo[,-1] #Remove gene ID column since it's redundant with row names
head(geneInfo) #Check formatting
```

```{r}
write.table(geneInfo, "zosteraGeneList-WGCNA-MM-GS-Annot.txt", sep = "\t", col.names = TRUE, row.names = TRUE, quote = FALSE) #Save master table again
```

# Plot module eigengene expression by treatment

```{r}
rownames(sigModules)
```

## brown

```{r}
brown <- data.frame(expr = MEs$MEbrown, 
                    exposed = zosteraTraits$exposed,
                    row.names = rownames(zosteraTraits)) %>%
  mutate(., condition = case_when(exposed == 1 ~ "Exposed",
                                  exposed == 0 ~ "Control")) %>%
  select(., -exposed) #Create dataframe for ME expression
head(brown)
```

```{r}
ggplot(brown, aes(x = condition, y = expr)) +
  geom_boxplot(lwd = 1, color = "brown") +
  labs(y = "Module Expression", 
       x = "", title = "brown Module", 
       subtitle = paste("r =", signif(sigModules$cor[1], 2), "p =", signif(sigModules$pvalue[1], 2), "\n457 Genes, 266 DEG")) +
  theme_classic() +theme(axis.text = element_text(size = 12), 
                         axis.title = element_text(size = 20),
                         strip.text.x = element_text(size = 20),
                         panel.grid = element_blank(),
                         plot.title = element_text(size = 20, hjust = 0.5, face = "bold"),
                         plot.subtitle = element_text(size = 16, hjust = 0.5, face = "plain"))

ggsave("brown-expression-boxplot.pdf", height = 8.5, width = 11)
```

## yellow

```{r}
yellow <- data.frame(expr = MEs$MEyellow, 
                     exposed = zosteraTraits$exposed,
                     row.names = rownames(zosteraTraits)) %>%
  mutate(., condition = case_when(exposed == 1 ~ "Exposed",
                                  exposed == 0 ~ "Control")) %>%
  select(., -exposed) #Create dataframe for ME expression
head(yellow)
```

```{r}
ggplot(yellow, aes(x = condition, y = expr)) +
  geom_boxplot(lwd = 1, color = "goldenrod1") +
  labs(y = "Module Expression", 
       x = "", title = "yellow Module", 
       subtitle = paste("r =", signif(sigModules$cor[2], 2), "p =", signif(sigModules$pvalue[2], 2), "\n230 Genes, 36 DEG")) +
  theme_classic() +theme(axis.text = element_text(size = 12), 
                         axis.title = element_text(size = 20),
                         strip.text.x = element_text(size = 20),
                         panel.grid = element_blank(),
                         plot.title = element_text(size = 20, hjust = 0.5, face = "bold"),
                         plot.subtitle = element_text(size = 16, hjust = 0.5, face = "plain"))

ggsave("yellow-expression-boxplot.pdf", height = 8.5, width = 11)
```

## blue

```{r}
blue <- data.frame(expr = MEs$MEblue, 
                   exposed = zosteraTraits$exposed,
                   row.names = rownames(zosteraTraits)) %>%
  mutate(., condition = case_when(exposed == 1 ~ "Exposed",
                                  exposed == 0 ~ "Control")) %>%
  select(., -exposed) #Create dataframe for ME expression
head(blue)
```

```{r}
ggplot(blue, aes(x = condition, y = expr)) +
  geom_boxplot(lwd = 1, color = "blue") +
  labs(y = "Module Expression", 
       x = "", title = "blue Module", 
       subtitle = paste("r =", signif(sigModules$cor[3], 2), "p =", signif(sigModules$pvalue[3], 2), "\n388 genes, 319 DEG")) +
  theme_classic() +theme(axis.text = element_text(size = 12), 
                         axis.title = element_text(size = 20),
                         strip.text.x = element_text(size = 20),
                         panel.grid = element_blank(),
                         plot.title = element_text(size = 20, hjust = 0.5, face = "bold"),
                         plot.subtitle = element_text(size = 16, hjust = 0.5, face = "plain"))

ggsave("blue-expression-boxplot.pdf", height = 8.5, width = 11)
```

## magenta

```{r}
magenta <- data.frame(expr = MEs$MEmagenta, 
                      exposed = zosteraTraits$exposed,
                      row.names = rownames(zosteraTraits)) %>%
  mutate(., condition = case_when(exposed == 1 ~ "Exposed",
                                  exposed == 0 ~ "Control")) %>%
  select(., -exposed) #Create dataframe for ME expression
head(magenta)
```

```{r}
ggplot(magenta, aes(x = condition, y = expr)) +
  geom_boxplot(lwd = 1, color = "magenta") +
  labs(y = "Module Expression", 
       x = "", title = "magenta Module", 
       subtitle = paste("r =", signif(sigModules$cor[4], 2), "p =", signif(sigModules$pvalue[4], 2), "\n126 genes, 67 DEG")) +
  theme_classic() +theme(axis.text = element_text(size = 12), 
                         axis.title = element_text(size = 20),
                         strip.text.x = element_text(size = 20),
                         panel.grid = element_blank(),
                         plot.title = element_text(size = 20, hjust = 0.5, face = "bold"),
                         plot.subtitle = element_text(size = 16, hjust = 0.5, face = "plain"))

ggsave("magenta-expression-boxplot.pdf", height = 8.5, width = 11)
```

## Create multipanel plot

```{r}
#Create and save individual plots as objects

brownPlot <- ggplot(brown, aes(x = condition, y = expr)) +
  geom_boxplot(lwd = 1, color = "brown") +
  labs(y = "", 
       x = "", title = "brown", 
       subtitle = paste("r =", signif(sigModules$cor[1], 2), "p =", signif(sigModules$pvalue[1], 2), "\n457 Genes, 266 DEG")) +
  theme_classic() + theme(axis.text = element_text(size = 16), 
                         strip.text.x = element_text(size = 20),
                         panel.grid = element_blank(),
                         plot.title = element_text(size = 20, hjust = 0.5, face = "bold"),
                         plot.subtitle = element_text(size = 16, hjust = 0.5, face = "plain"))

yellowPlot <- ggplot(yellow, aes(x = condition, y = expr)) +
  geom_boxplot(lwd = 1, color = "goldenrod1") +
  labs(y = "", 
       x = "", title = "yellow", 
       subtitle = paste("r =", signif(sigModules$cor[2], 2), "p =", signif(sigModules$pvalue[2], 2), "\n230 Genes, 36 DEG")) +
  theme_classic() + theme(axis.text = element_text(size = 16), 
                         strip.text.x = element_text(size = 20),
                         panel.grid = element_blank(),
                         plot.title = element_text(size = 20, hjust = 0.5, face = "bold"),
                         plot.subtitle = element_text(size = 16, hjust = 0.5, face = "plain"))

bluePlot <- ggplot(blue, aes(x = condition, y = expr)) +
  geom_boxplot(lwd = 1, color = "blue") +
  labs(y = "", 
       x = "", title = "blue", 
       subtitle = paste("r =", signif(sigModules$cor[3], 2), "p =", signif(sigModules$pvalue[3], 2), "\n388 genes, 319 DEG")) +
  theme_classic() + theme(axis.text = element_text(size = 16), 
                         strip.text.x = element_text(size = 20),
                         panel.grid = element_blank(),
                         plot.title = element_text(size = 20, hjust = 0.5, face = "bold"),
                         plot.subtitle = element_text(size = 16, hjust = 0.5, face = "plain"))

magentaPlot <- ggplot(magenta, aes(x = condition, y = expr)) +
  geom_boxplot(lwd = 1, color = "magenta") +
  labs(y = "", 
       x = "", title = "magenta", 
       subtitle = paste("r =", signif(sigModules$cor[4], 2), "p =", signif(sigModules$pvalue[4], 2), "\n126 genes, 67 DEG")) +
  theme_classic() + theme(axis.text = element_text(size = 16), 
                         strip.text.x = element_text(size = 20),
                         panel.grid = element_blank(),
                         plot.title = element_text(size = 20, hjust = 0.5, face = "bold"),
                         plot.subtitle = element_text(size = 16, hjust = 0.5, face = "plain"))
```

```{r}
#Use patchwork to stitch plots together

#pdf("multipanel-expression-boxplot.pdf", height = 8.5, width = 11)

brownPlot / bluePlot | yellowPlot / magentaPlot
grid::grid.draw(grid::textGrob("Module Expression", x = 0.01, rot = 90, gp = gpar(fontsize = 25)))

#dev.off()
```

# GO-MWU

## Create GO-MWU inputs

For each significant module, I need a .csv of genes and module membership scores (kME) for my table of significance measures. Genes that are not in the module should have a kME = 0. I also need a GO annotations table with gene name and GO terms separated by semicolon.

### GO annotations table

```{r}
head(zosteraGeneAnnot)
```

```{r}
zosteraGOAnnotations <- zosteraGeneAnnot %>%
  select(., geneIDs, GOterms) %>%
  dplyr::rename(., GeneID = "geneIDs") %>%
  dplyr::rename(., GO = "GOterms") #Create GO annotations table
head(zosteraGOAnnotations) #Confirm table creation
```

```{r}
write.table(zosteraGOAnnotations, "GO-Annotations-Table.tab", sep = "\t", col.names = FALSE, row.names = FALSE, quote = FALSE) #Save file
```

```{bash}
head GO-Annotations-Table.tab #Confirm formatting is good.
wc -l GO-Annotations-Table.tab #Number of genes in the original document
```

I will create the .csv files for each module separately.

### Table of significance measures


#### brown

```{r}
brownGOMWUInput <- data.frame("geneID" = rownames(geneInfo),
                              "moduleColor" = geneInfo$moduleColor,
                              "MM.brown" = geneInfo$MM.brown) %>%
  mutate(kME = case_when(moduleColor == "brown" ~ MM.brown,
                         moduleColor != "brown" ~ 0)) %>%
  select(., geneID, kME) #Create table of significance measures
head(brownGOMWUInput) #Confirm formatting
```

```{r}
write.csv(brownGOMWUInput,"brown-Table-of-Significance-Measures.csv", quote = FALSE, row.names = FALSE) #Save file
```

#### yellow

```{r}
yellowGOMWUInput <- data.frame("geneID" = rownames(geneInfo),
                              "moduleColor" = geneInfo$moduleColor,
                              "MM.yellow" = geneInfo$MM.yellow) %>%
  mutate(kME = case_when(moduleColor == "yellow" ~ MM.yellow,
                         moduleColor != "yellow" ~ 0)) %>%
  select(., geneID, kME) #Create table of significance measures
head(yellowGOMWUInput) #Confirm formatting
```

```{r}
write.csv(yellowGOMWUInput,"yellow-Table-of-Significance-Measures.csv", quote = FALSE, row.names = FALSE) #Save file
```

#### blue

```{r}
blueGOMWUInput <- data.frame("geneID" = rownames(geneInfo),
                              "moduleColor" = geneInfo$moduleColor,
                              "MM.blue" = geneInfo$MM.blue) %>%
  mutate(kME = case_when(moduleColor == "blue" ~ MM.blue,
                         moduleColor != "blue" ~ 0)) %>%
  select(., geneID, kME) #Create table of significance measures
head(blueGOMWUInput) #Confirm formatting
```

```{r}
write.csv(blueGOMWUInput,"blue-Table-of-Significance-Measures.csv", quote = FALSE, row.names = FALSE) #Save file
```

#### magenta

```{r}
magentaGOMWUInput <- data.frame("geneID" = rownames(geneInfo),
                              "moduleColor" = geneInfo$moduleColor,
                              "MM.magenta" = geneInfo$MM.magenta) %>%
  mutate(kME = case_when(moduleColor == "magenta" ~ MM.magenta,
                         moduleColor != "magenta" ~ 0)) %>%
  select(., geneID, kME) #Create table of significance measures
head(magentaGOMWUInput) #Confirm formatting
```

```{r}
write.csv(magentaGOMWUInput,"magenta-Table-of-Significance-Measures.csv", quote = FALSE, row.names = FALSE) #Save file
```

## Run GO-MWU

### Brown (exposed and control)

#### Biological processes

```{r}
input="BrownGeneList.csv" # two columns of comma-separated values: gene id, continuous measure of significance. To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).
goAnnotations="Zostera-GO-Annotations-Table.tab" # two-column, tab-delimited, one line per gene, multiple GO terms separated by semicolon. If you have multiple lines per gene, use nrify_GOtable.pl prior to running this script.
goDatabase="go.obo" # download from http://www.geneontology.org/GO.downloads.ontology.shtml
goDivision="BP" # either MF, or BP, or CC
source("gomwu.functions.R")
```

```{r}
# Calculating stats. It might take ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs, go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.
gomwuStats(input, goDatabase, goAnnotations, goDivision,
           perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already
           largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
           smallest=5,   # a GO category should contain at least this many genes to be considered
           clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for details.
           #	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead. 
           Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
           #	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module 
)
# do not continue if the printout shows that no GO terms pass 10% FDR.

# 0  GO terms at 10% FDR, no significant GOterms. Will not proceed with plotting.
```

```{r}

```

#### Cellular components

```{r}
goDivision="CC" # either MF, or BP, or CC
```

```{r}
# Calculating stats. It might take ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs, go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.
gomwuStats(input, goDatabase, goAnnotations, goDivision,
           perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already
           largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
           smallest=5,   # a GO category should contain at least this many genes to be considered
           clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for details.
           #	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead. 
           Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
           #	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module 
)
# do not continue if the printout shows that no GO terms pass 10% FDR.

# 0  GO terms at 10% FDR, no significant GOterms. Will not proceed with plotting.
```

#### Molecular function

```{r}
goDivision="MF" # either MF, or BP, or CC
```

```{r}
# Calculating stats. It might take ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs, go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.
gomwuStats(input, goDatabase, goAnnotations, goDivision,
           perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already
           largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
           smallest=5,   # a GO category should contain at least this many genes to be considered
           clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for details.
           #	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead. 
           Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
           #	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module 
)
# do not continue if the printout shows that no GO terms pass 10% FDR.

# 0  GO terms at 10% FDR, no significant GOterms. Will not proceed with plotting.
```

### Black (exposed)

#### Biological processes

```{r}
input="BlackGeneList.csv" # two columns of comma-separated values: gene id, continuous measure of significance. To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).
goDivision="BP" # either MF, or BP, or CC
```

```{r}
# Calculating stats. It might take ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs, go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.
gomwuStats(input, goDatabase, goAnnotations, goDivision,
           perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already
           largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
           smallest=5,   # a GO category should contain at least this many genes to be considered
           clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for details.
           #	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead. 
           Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
           #	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module 
)
# do not continue if the printout shows that no GO terms pass 10% FDR.

# 0  GO terms at 10% FDR, no significant GOterms. Will not proceed with plotting.
```

#### Cellular components

```{r}
goDivision="CC" # either MF, or BP, or CC
```

```{r}
# Calculating stats. It might take ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs, go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.
gomwuStats(input, goDatabase, goAnnotations, goDivision,
           perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already
           largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
           smallest=5,   # a GO category should contain at least this many genes to be considered
           clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for details.
           #	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead. 
           Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
           #	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module 
)
# do not continue if the printout shows that no GO terms pass 10% FDR.

# 0  GO terms at 10% FDR, no significant GOterms. Will not proceed with plotting.
```

#### Molecular function

```{r}
goDivision="MF" # either MF, or BP, or CC
```

```{r}
# Calculating stats. It might take ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs, go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.
gomwuStats(input, goDatabase, goAnnotations, goDivision,
           perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already
           largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
           smallest=5,   # a GO category should contain at least this many genes to be considered
           clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for details.
           #	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead. 
           Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
           #	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module 
)
# do not continue if the printout shows that no GO terms pass 10% FDR.

# 2  GO terms at 10% FDR.
```

##### Match significant results with gene information

```{r}
blackMFGOMWUResults <- read.csv("MWU_MF_BlackGeneList.csv", sep = "") #Import GO-MWU results for significant test
head(blackMFGOMWUResults) #Confirm import
```

```{r}
blackMFGOMWUSig <- blackMFGOMWUResults %>% 
  filter(., p.adj < 0.05) %>%
  select(., term, name, p.adj) %>%
  separate_rows(., term, sep=";") #Filter rows with significant GOterms, retain GOterm information columns, then separate GOterms into different rows
colnames(blackMFGOMWUSig) <- c("GOID", "GOterm", "GOMWU.p.adj") #Revise column names
head(blackMFGOMWUSig) #Confirm formatting
```

```{r}
blackMFGOMWUMatchedGenes <- read.csv("MF_BlackGeneList.csv", sep = "") #Import GO-MWU generated list of GOterms and matched genes
blackMFGOMWUMatchedGenes <- blackMFGOMWUMatchedGenes %>%
  select(., term, seq) %>%
  separate_rows(., term, sep=";") #Select GOterm and geneID columns, then separate GOterms into different rows
colnames(blackMFGOMWUMatchedGenes) <- c("GOID", "geneIDs") #Revise column names
head(blackMFGOMWUMatchedGenes) #Confirm import
```

```{r}
blackMFGOMWUGeneGOterms <- left_join(blackMFGOMWUSig, blackMFGOMWUMatchedGenes, by = "GOID") #Join GOterms with gene IDs
head(blackMFGOMWUGeneGOterms) #Confirm formatting

blackMFGOMWUGeneGOtermsEdgeR <- left_join(blackMFGOMWUGeneGOterms, zosteraDEG, by = "geneIDs") #Join geneIDs with edgeR results
head(blackMFGOMWUGeneGOtermsEdgeR) #Confirm formatting

length(unique(blackMFGOMWUGeneGOterms$geneIDs)) == length(unique(blackMFGOMWUGeneGOtermsEdgeR$geneIDs)) #Confirm all matched genes have edgeR values
```

```{r}
length(unique(blackMFGOMWUGeneGOtermsEdgeR$geneIDs)) #Number of unique genes associated with GOterms = 126

blackMFGOMWUGeneGOtermsEdgeR %>% 
  filter(., edgeR.pvalue < 0.05 & abs(logFC) > 10) %>%
  distinct(., geneIDs) %>%
  summarise(., length(geneIDs)) #Retain rows where there is an edgeR p-value, identify unique geneIDs, then count the number of unique geneIDs

#Number of DEG in module = 7
```

```{r}
write.csv(blackMFGOMWUGeneGOtermsEdgeR, "zostera-BlackModule-EnrichedGOterms-DEG.csv", quote = FALSE, row.names = FALSE) #Save as .csv
```

### Blue (exposed and control)

#### Biological processes

```{r}
input="BlueGeneList.csv" # two columns of comma-separated values: gene id, continuous measure of significance. To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).
goDivision="BP" # either MF, or BP, or CC
```

```{r}
# Calculating stats. It might take ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs, go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.
gomwuStats(input, goDatabase, goAnnotations, goDivision,
           perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already
           largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
           smallest=5,   # a GO category should contain at least this many genes to be considered
           clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for details.
           #	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead. 
           Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
           #	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module 
)
# do not continue if the printout shows that no GO terms pass 10% FDR.

# 2  GO terms at 10% FDR, no significant GOterms.
```

##### Match significant results with gene information

```{r}
blueBPGOMWUResults <- read.csv("MWU_BP_BlueGeneList.csv", sep = "") #Import GO-MWU results for significant test
head(blueBPGOMWUResults) #Confirm import
```

```{r}
blueBPGOMWUSig <- blueBPGOMWUResults %>% 
  filter(., p.adj < 0.05) %>%
  select(., term, name, p.adj) %>%
  separate_rows(., term, sep=";") #Filter rows with significant GOterms, retain GOterm information columns, then separate GOterms into different rows
colnames(blueBPGOMWUSig) <- c("GOID", "GOterm", "GOMWU.p.adj") #Revise column names
head(blueBPGOMWUSig) #Confirm formatting
```

```{r}
blueBPGOMWUMatchedGenes <- read.csv("BP_BlueGeneList.csv", sep = "") #Import GO-MWU generated list of GOterms and matched genes
blueBPGOMWUMatchedGenes <- blueBPGOMWUMatchedGenes %>%
  select(., term, seq) %>%
  separate_rows(., term, sep=";") #Select GOterm and geneID columns, then separate GOterms into different rows
colnames(blueBPGOMWUMatchedGenes) <- c("GOID", "geneIDs") #Revise column names
head(blueBPGOMWUMatchedGenes) #Confirm import
```

```{r}
blueBPGOMWUGeneGOterms <- left_join(blueBPGOMWUSig, blueBPGOMWUMatchedGenes, by = "GOID") #Join GOterms with gene IDs
head(blueBPGOMWUGeneGOterms) #Confirm formatting

blueBPGOMWUGeneGOtermsEdgeR <- left_join(blueBPGOMWUGeneGOterms, zosteraDEG, by = "geneIDs") #Join geneIDs with edgeR results
head(blueBPGOMWUGeneGOtermsEdgeR) #Confirm formatting

length(unique(blueBPGOMWUGeneGOterms$geneIDs)) == length(unique(blueBPGOMWUGeneGOtermsEdgeR$geneIDs)) #Confirm all matched genes have edgeR values
```

```{r}
length(unique(blueBPGOMWUGeneGOtermsEdgeR$geneIDs)) #Number of unique genes associated with GOterms = 8

blueBPGOMWUGeneGOtermsEdgeR %>% 
  filter(., edgeR.pvalue < 0.05 & abs(logFC) > 10) %>%
  distinct(., geneIDs) %>%
  summarise(., length(geneIDs)) #Retain rows where there is an edgeR p-value, identify unique geneIDs, then count the number of unique geneIDs

#Number of DEG in module = 3
```

```{r}
write.csv(blueBPGOMWUGeneGOtermsEdgeR, "zostera-BlueModule-EnrichedGOterms-DEG.csv", quote = FALSE, row.names = FALSE) #Save as .csv
```

#### Cellular components

```{r}
goDivision="CC" # either MF, or BP, or CC
```

```{r}
# Calculating stats. It might take ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs, go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.
gomwuStats(input, goDatabase, goAnnotations, goDivision,
           perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already
           largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
           smallest=5,   # a GO category should contain at least this many genes to be considered
           clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for details.
           #	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead. 
           Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
           #	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module 
)
# do not continue if the printout shows that no GO terms pass 10% FDR.

# 0  GO terms at 10% FDR, no significant GOterms. Will not proceed with plotting.
```

#### Molecular function

```{r}
goDivision="MF" # either MF, or BP, or CC
```

```{r}
# Calculating stats. It might take ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs, go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.
gomwuStats(input, goDatabase, goAnnotations, goDivision,
           perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already
           largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
           smallest=5,   # a GO category should contain at least this many genes to be considered
           clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for details.
           #	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead. 
           Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
           #	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module 
)
# do not continue if the printout shows that no GO terms pass 10% FDR.

# 0  GO terms at 10% FDR, no significant GOterms. Will not proceed with plotting.
```

### Yellow (control)

#### Biological processes

```{r}
input="YellowGeneList.csv" # two columns of comma-separated values: gene id, continuous measure of significance. To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).
goDivision="BP" # either MF, or BP, or CC
```

```{r}
# Calculating stats. It might take ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs, go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.
gomwuStats(input, goDatabase, goAnnotations, goDivision,
           perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already
           largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
           smallest=5,   # a GO category should contain at least this many genes to be considered
           clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for details.
           #	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead. 
           Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
           #	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module 
)
# do not continue if the printout shows that no GO terms pass 10% FDR.

# 0  GO terms at 10% FDR, no significant GOterms. Will not proceed with plotting.
```

#### Cellular components

```{r}
goDivision="CC" # either MF, or BP, or CC
```

```{r}
# Calculating stats. It might take ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs, go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.
gomwuStats(input, goDatabase, goAnnotations, goDivision,
           perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already
           largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
           smallest=5,   # a GO category should contain at least this many genes to be considered
           clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for details.
           #	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead. 
           Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
           #	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module 
)
# do not continue if the printout shows that no GO terms pass 10% FDR.

# 0  GO terms at 10% FDR, no significant GOterms. Will not proceed with plotting.
```

#### Molecular function

```{r}
goDivision="MF" # either MF, or BP, or CC
```

```{r}
# Calculating stats. It might take ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs, go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.
gomwuStats(input, goDatabase, goAnnotations, goDivision,
           perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already
           largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
           smallest=5,   # a GO category should contain at least this many genes to be considered
           clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for details.
           #	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead. 
           Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
           #	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module 
)
# do not continue if the printout shows that no GO terms pass 10% FDR.

# 0  GO terms at 10% FDR, no significant GOterms. Will not proceed with plotting.
```

### Light green (control)

#### Biological processes

```{r}
input="LightgreenGeneList.csv" # two columns of comma-separated values: gene id, continuous measure of significance. To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).
goDivision="BP" # either MF, or BP, or CC
```

```{r}
# Calculating stats. It might take ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs, go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.
gomwuStats(input, goDatabase, goAnnotations, goDivision,
           perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already
           largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
           smallest=5,   # a GO category should contain at least this many genes to be considered
           clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for details.
           #	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead. 
           Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
           #	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module 
)
# do not continue if the printout shows that no GO terms pass 10% FDR.

# 0  GO terms at 10% FDR, no significant GOterms. Will not proceed with plotting.
```

#### Cellular components

```{r}
goDivision="CC" # either MF, or BP, or CC
```

```{r}
# Calculating stats. It might take ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs, go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.
gomwuStats(input, goDatabase, goAnnotations, goDivision,
           perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already
           largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
           smallest=5,   # a GO category should contain at least this many genes to be considered
           clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for details.
           #	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead. 
           Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
           #	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module 
)
# do not continue if the printout shows that no GO terms pass 10% FDR.

# 0  GO terms at 10% FDR, no significant GOterms. Will not proceed with plotting.
```

#### Molecular function

```{r}
goDivision="MF" # either MF, or BP, or CC
```

```{r}
# Calculating stats. It might take ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs, go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.
gomwuStats(input, goDatabase, goAnnotations, goDivision,
           perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already
           largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
           smallest=5,   # a GO category should contain at least this many genes to be considered
           clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for details.
           #	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead. 
           Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
           #	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module 
)
# do not continue if the printout shows that no GO terms pass 10% FDR.

# 0  GO terms at 10% FDR, no significant GOterms. Will not proceed with plotting.
```






